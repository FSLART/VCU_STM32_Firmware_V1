/**
 * @file data_dbc.h
 *
 * @brief This header file was generated by cantools version 40.2.3 Thu Jun 26 17:38:38 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef DATA_DBC_H
#define DATA_DBC_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define DATA_DBC_VCU__FRAME_ID (0x20u)
#define DATA_DBC_VCU_1_FRAME_ID (0x21u)
#define DATA_DBC_VCU_2_FRAME_ID (0x22u)
#define DATA_DBC_VCU_3_FRAME_ID (0x23u)
#define DATA_DBC_VCU_4_FRAME_ID (0x24u)
#define DATA_DBC_IMU__FRAME_ID (0x60u)
#define DATA_DBC_IMU_1_FRAME_ID (0x61u)
#define DATA_DBC_DYNAMIC_R_FRAME_ID (0x80u)
#define DATA_DBC_DYNAMIC_F_FRAME_ID (0xa0u)
#define DATA_DBC_DATA_LOGGER_FRAME_ID (0x180u)

/* Frame lengths in bytes. */
#define DATA_DBC_VCU__LENGTH (8u)
#define DATA_DBC_VCU_1_LENGTH (8u)
#define DATA_DBC_VCU_2_LENGTH (8u)
#define DATA_DBC_VCU_3_LENGTH (8u)
#define DATA_DBC_VCU_4_LENGTH (8u)
#define DATA_DBC_IMU__LENGTH (8u)
#define DATA_DBC_IMU_1_LENGTH (8u)
#define DATA_DBC_DYNAMIC_R_LENGTH (8u)
#define DATA_DBC_DYNAMIC_F_LENGTH (8u)
#define DATA_DBC_DATA_LOGGER_LENGTH (8u)

/* Extended or standard frame types. */
#define DATA_DBC_VCU__IS_EXTENDED (0)
#define DATA_DBC_VCU_1_IS_EXTENDED (0)
#define DATA_DBC_VCU_2_IS_EXTENDED (0)
#define DATA_DBC_VCU_3_IS_EXTENDED (0)
#define DATA_DBC_VCU_4_IS_EXTENDED (0)
#define DATA_DBC_IMU__IS_EXTENDED (0)
#define DATA_DBC_IMU_1_IS_EXTENDED (0)
#define DATA_DBC_DYNAMIC_R_IS_EXTENDED (0)
#define DATA_DBC_DYNAMIC_F_IS_EXTENDED (0)
#define DATA_DBC_DATA_LOGGER_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define DATA_DBC_VCU__NAME "VCU_"
#define DATA_DBC_VCU_1_NAME "VCU_1"
#define DATA_DBC_VCU_2_NAME "VCU_2"
#define DATA_DBC_VCU_3_NAME "VCU_3"
#define DATA_DBC_VCU_4_NAME "VCU_4"
#define DATA_DBC_IMU__NAME "IMU_"
#define DATA_DBC_IMU_1_NAME "IMU_1"
#define DATA_DBC_DYNAMIC_R_NAME "Dynamic_R"
#define DATA_DBC_DYNAMIC_F_NAME "Dynamic_F"
#define DATA_DBC_DATA_LOGGER_NAME "DataLogger"

/* Signal Names. */
#define DATA_DBC_VCU__APPS_NAME "APPS"
#define DATA_DBC_VCU__BPS_NAME "BPS"
#define DATA_DBC_VCU__TRGT_POWER_NAME "TRGT_Power"
#define DATA_DBC_VCU__CNSM_POWER_NAME "CNSM_Power"
#define DATA_DBC_VCU_1_INV_TEMPERATURE_NAME "INV_Temperature"
#define DATA_DBC_VCU_1_MOTOR_TEMPERATURE_NAME "Motor_Temperature"
#define DATA_DBC_VCU_1_BMS_VOLTAGE_NAME "BMS_Voltage"
#define DATA_DBC_VCU_1_SOC_HV_NAME "SOC_HV"
#define DATA_DBC_VCU_2_INV_FAULTS_NAME "INV_Faults"
#define DATA_DBC_VCU_2_LMT1_NAME "LMT1"
#define DATA_DBC_VCU_2_LMT2_NAME "LMT2"
#define DATA_DBC_VCU_2_VCU_STATE_NAME "VCU_State"
#define DATA_DBC_VCU_2_APPS_ERROR_NAME "APPS_Error"
#define DATA_DBC_VCU_2_POWER_PLAN_NAME "Power_Plan"
#define DATA_DBC_VCU_3_INV_VOLTAGE_NAME "INV_Voltage"
#define DATA_DBC_VCU_3_RPM_NAME "RPM"
#define DATA_DBC_VCU_3_IGN_NAME "IGN"
#define DATA_DBC_VCU_3_R2_D_NAME "R2D"
#define DATA_DBC_VCU_4_TCU_STATE_NAME "TCU_State"
#define DATA_DBC_VCU_4_ACU_STATE_NAME "ACU_State"
#define DATA_DBC_VCU_4_ALC_STATE_NAME "ALC_State"
#define DATA_DBC_VCU_4_LV_SOC_NAME "LV_SOC"
#define DATA_DBC_VCU_4_LV_VOLTAGE_NAME "LV_Voltage"
#define DATA_DBC_IMU__ACCEL_X_INT_NAME "AccelX_int"
#define DATA_DBC_IMU__ACCEL_Y_DEC_NAME "AccelY_dec"
#define DATA_DBC_IMU__ACCEL_Z_INT_NAME "AccelZ_int"
#define DATA_DBC_IMU__HEATBIT_NAME "Heatbit"
#define DATA_DBC_IMU_1_ROLL_INT_NAME "roll_int"
#define DATA_DBC_IMU_1_PITCH_DEC_NAME "pitch_dec"
#define DATA_DBC_IMU_1_YAW_INT_NAME "yaw_int"
#define DATA_DBC_IMU_1_HEARTBIT_NAME "Heartbit"
#define DATA_DBC_DYNAMIC_R_WHEEL_SPEED_RL_NAME "Wheel_Speed_RL"
#define DATA_DBC_DYNAMIC_R_WHEEL_SPEED_RR_NAME "Wheel_Speed_RR"
#define DATA_DBC_DYNAMIC_R_SUS_POS_RL_NAME "SusPos_RL"
#define DATA_DBC_DYNAMIC_R_SUS_POS_RR_NAME "SusPos_RR"
#define DATA_DBC_DYNAMIC_R_RR_PC_NAME "RR_PC"
#define DATA_DBC_DYNAMIC_R_RL_PC_NAME "RL_PC"
#define DATA_DBC_DYNAMIC_R_DY_ST_NAME "DY_ST"
#define DATA_DBC_DYNAMIC_F_WHEEL_SPEED_FL_NAME "Wheel_Speed_FL"
#define DATA_DBC_DYNAMIC_F_WHEEL_SPEED_FR_NAME "Wheel_Speed_FR"
#define DATA_DBC_DYNAMIC_F_SUS_POS_FL_NAME "SusPos_FL"
#define DATA_DBC_DYNAMIC_F_SUS_POS_FR_NAME "SusPos_FR"
#define DATA_DBC_DYNAMIC_F_FR_PC_NAME "FR_PC"
#define DATA_DBC_DYNAMIC_F_FL_PC_NAME "FL_PC"
#define DATA_DBC_DYNAMIC_F_DY_ST_NAME "DY_ST"
#define DATA_DBC_DATA_LOGGER_DL_STATE_NAME "DL_state"
#define DATA_DBC_DATA_LOGGER_RECORDING_STATE_NAME "Recording_State"

/**
 * Signals in message VCU_.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu__t {
    /**
     * Accelerator_Pedal_Position_Sense
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps;

    /**
     * Brake_Pressure
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bps;

    /**
     * Target_Power
     *
     * Range: 0..85000 (0..85000 W)
     * Scale: 1
     * Offset: 0
     */
    uint32_t trgt_power;

    /**
     * Current Consumed Power
     *
     * Range: 0..85000 (0..85000 W)
     * Scale: 1
     * Offset: 0
     */
    uint32_t cnsm_power;
};

/**
 * Signals in message VCU_1.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_1_t {
    /**
     * Inverter_Temperature
     *
     * Range: -40..260 (0..300 ºC)
     * Scale: 1
     * Offset: 40
     */
    uint16_t inv_temperature;

    /**
     * Motor_Temperature
     *
     * Range: -40..60 (0..100 ºC)
     * Scale: 1
     * Offset: 40
     */
    uint16_t motor_temperature;

    /**
     * bms_voltage
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_voltage;

    /**
     * SOC_HV
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_hv;
};

/**
 * Signals in message VCU_2.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_2_t {
    /**
     * INVERSOR_ERROR
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inv_faults;

    /**
     * RPM_Power_Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt1;

    /**
     * Current_Limit_Motor_Temp
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt2;

    /**
     * VCU_State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_state;

    /**
     * APPS_Error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_error;

    /**
     * Power_Plan_Switch_Volante
     *
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_plan;
};

/**
 * Signals in message VCU_3.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_3_t {
    /**
     * DC_Link_Inverter_Voltage
     *
     * Range: 0..620 (0..620 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inv_voltage;

    /**
     * RPM
     *
     * Range: 0..7000 (0..7000 RPM)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rpm;

    /**
     * Ignition
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ign;

    /**
     * Ready to drive
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r2_d;
};

/**
 * Signals in message VCU_4.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_vcu_4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tcu_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t acu_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t alc_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t lv_soc;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t lv_voltage;
};

/**
 * Signals in message IMU_.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_imu__t {
    /**
     * X Acceleration Integer  (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t accel_x_int;

    /**
     * Y Acceleration Integer  (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t accel_y_dec;

    /**
     * Z Acceleration Integer (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accel_z_int;

    /**
     * Heartbit
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t heatbit;
};

/**
 * Signals in message IMU_1.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_imu_1_t {
    /**
     * roll integer  (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t roll_int;

    /**
     * pitch integer (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t pitch_dec;

    /**
     * yaw integer (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t yaw_int;

    /**
     * Heartbit (/100 para int,dec)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t heartbit;
};

/**
 * Signals in message Dynamic_R.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_dynamic_r_t {
    /**
     * Wheel Speed RL
     *
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_rl;

    /**
     * Wheel Speed RR
     *
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_rr;

    /**
     * SusPos RL
     *
     * Range: 0..50 (0..50 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sus_pos_rl;

    /**
     * SusPos RR
     *
     * Range: 0..50 (0..50 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sus_pos_rr;

    /**
     * RR_Pulse_Count
     *
     * Range: 0..30 (0..30 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rr_pc;

    /**
     * RL_Pulse_Count
     *
     * Range: 0..30 (0..30 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rl_pc;

    /**
     * DY ST
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dy_st;
};

/**
 * Signals in message Dynamic_F.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_dynamic_f_t {
    /**
     * Wheel Speed FL
     *
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_fl;

    /**
     * Wheel Speed FR
     *
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t wheel_speed_fr;

    /**
     * SusPos FL
     *
     * Range: 0..50 (0..50 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sus_pos_fl;

    /**
     * SusPos FR
     *
     * Range: 0..50 (0..50 mm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sus_pos_fr;

    /**
     * FR_Pulse_Count
     *
     * Range: 0..30 (0..30 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fr_pc;

    /**
     * FL_Pulse_Count
     *
     * Range: 0..30 (0..30 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fl_pc;

    /**
     * DY ST
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dy_st;
};

/**
 * Signals in message DataLogger.
 *
 * All signal values are as on the CAN bus.
 */
struct data_dbc_data_logger_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dl_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t recording_state;
};

/**
 * Pack message VCU_.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu__pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu__t *src_p,
    size_t size);

/**
 * Unpack message VCU_.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu__unpack(
    struct data_dbc_vcu__t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu__init(struct data_dbc_vcu__t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu__apps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__apps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__apps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu__bps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__bps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__bps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t data_dbc_vcu__trgt_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__trgt_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__trgt_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t data_dbc_vcu__cnsm_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu__cnsm_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu__cnsm_power_is_in_range(uint32_t value);

/**
 * Pack message VCU_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_1_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_1_t *src_p,
    size_t size);

/**
 * Unpack message VCU_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_1_unpack(
    struct data_dbc_vcu_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_1_init(struct data_dbc_vcu_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_1_inv_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_inv_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_inv_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_1_motor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_motor_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_motor_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_1_bms_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_bms_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_bms_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_1_soc_hv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_1_soc_hv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_1_soc_hv_is_in_range(uint8_t value);

/**
 * Pack message VCU_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_2_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_2_t *src_p,
    size_t size);

/**
 * Unpack message VCU_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_2_unpack(
    struct data_dbc_vcu_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_2_init(struct data_dbc_vcu_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_2_inv_faults_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_inv_faults_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_inv_faults_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_lmt1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_lmt1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_lmt1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_lmt2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_lmt2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_lmt2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_vcu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_vcu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_vcu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_apps_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_apps_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_apps_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_2_power_plan_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_2_power_plan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_2_power_plan_is_in_range(uint8_t value);

/**
 * Pack message VCU_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_3_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_3_t *src_p,
    size_t size);

/**
 * Unpack message VCU_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_3_unpack(
    struct data_dbc_vcu_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_3_init(struct data_dbc_vcu_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_3_inv_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_inv_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_inv_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_3_rpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_rpm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_rpm_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_3_ign_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_ign_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_ign_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_3_r2_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_3_r2_d_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_3_r2_d_is_in_range(uint8_t value);

/**
 * Pack message VCU_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_vcu_4_pack(
    uint8_t *dst_p,
    const struct data_dbc_vcu_4_t *src_p,
    size_t size);

/**
 * Unpack message VCU_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_vcu_4_unpack(
    struct data_dbc_vcu_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_vcu_4_init(struct data_dbc_vcu_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_4_tcu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_tcu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_tcu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_4_acu_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_acu_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_acu_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_vcu_4_alc_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_alc_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_alc_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_4_lv_soc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_lv_soc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_lv_soc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_vcu_4_lv_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_vcu_4_lv_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_vcu_4_lv_voltage_is_in_range(uint16_t value);

/**
 * Pack message IMU_.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_imu__pack(
    uint8_t *dst_p,
    const struct data_dbc_imu__t *src_p,
    size_t size);

/**
 * Unpack message IMU_.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_imu__unpack(
    struct data_dbc_imu__t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU_.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_imu__init(struct data_dbc_imu__t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu__accel_x_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__accel_x_int_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__accel_x_int_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu__accel_y_dec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__accel_y_dec_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__accel_y_dec_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_imu__accel_z_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__accel_z_int_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__accel_z_int_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_imu__heatbit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu__heatbit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu__heatbit_is_in_range(uint8_t value);

/**
 * Pack message IMU_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_imu_1_pack(
    uint8_t *dst_p,
    const struct data_dbc_imu_1_t *src_p,
    size_t size);

/**
 * Unpack message IMU_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_imu_1_unpack(
    struct data_dbc_imu_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_imu_1_init(struct data_dbc_imu_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu_1_roll_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_roll_int_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_roll_int_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu_1_pitch_dec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_pitch_dec_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_pitch_dec_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t data_dbc_imu_1_yaw_int_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_yaw_int_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_yaw_int_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_imu_1_heartbit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_imu_1_heartbit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_imu_1_heartbit_is_in_range(uint8_t value);

/**
 * Pack message Dynamic_R.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_dynamic_r_pack(
    uint8_t *dst_p,
    const struct data_dbc_dynamic_r_t *src_p,
    size_t size);

/**
 * Unpack message Dynamic_R.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_dynamic_r_unpack(
    struct data_dbc_dynamic_r_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Dynamic_R.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_dynamic_r_init(struct data_dbc_dynamic_r_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_wheel_speed_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_wheel_speed_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_wheel_speed_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_wheel_speed_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_sus_pos_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_sus_pos_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_sus_pos_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_sus_pos_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_sus_pos_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_sus_pos_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_rr_pc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_rr_pc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_rr_pc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_rl_pc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_rl_pc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_rl_pc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_r_dy_st_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_r_dy_st_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_r_dy_st_is_in_range(uint8_t value);

/**
 * Pack message Dynamic_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_dynamic_f_pack(
    uint8_t *dst_p,
    const struct data_dbc_dynamic_f_t *src_p,
    size_t size);

/**
 * Unpack message Dynamic_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_dynamic_f_unpack(
    struct data_dbc_dynamic_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Dynamic_F.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_dynamic_f_init(struct data_dbc_dynamic_f_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_wheel_speed_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_wheel_speed_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_wheel_speed_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_wheel_speed_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_sus_pos_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_sus_pos_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_sus_pos_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_sus_pos_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_sus_pos_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_sus_pos_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_fr_pc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_fr_pc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_fr_pc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_fl_pc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_fl_pc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_fl_pc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_dynamic_f_dy_st_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_dynamic_f_dy_st_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_dynamic_f_dy_st_is_in_range(uint8_t value);

/**
 * Pack message DataLogger.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int data_dbc_data_logger_pack(
    uint8_t *dst_p,
    const struct data_dbc_data_logger_t *src_p,
    size_t size);

/**
 * Unpack message DataLogger.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int data_dbc_data_logger_unpack(
    struct data_dbc_data_logger_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DataLogger.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int data_dbc_data_logger_init(struct data_dbc_data_logger_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_data_logger_dl_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_data_logger_dl_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_data_logger_dl_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t data_dbc_data_logger_recording_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double data_dbc_data_logger_recording_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool data_dbc_data_logger_recording_state_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
